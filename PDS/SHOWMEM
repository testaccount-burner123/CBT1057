/* REXX    SHOWMEM    Display a requested member list with ISPF stats
                      in a TBDISPL format.  Allows users to browse,
                      edit, print, delete, acquire and roll members.
                      Acquire and Roll were built for the CM Tools
                      group.
   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|
   |                                                                 |
   |          WARNING: EMBEDDED COMPONENTS.                          |
   |                      See text following TOOLKIT_INIT            |
   |                                                                 |
   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|

           Written by Chris Lewis 19950426

     Impact Analysis
x    SYSEXEC   HURL         ship dataset via NDM
.    SYSEXEC   ICEUSER      Special userids
.    SYSEXEC   LA           LISTA to stack
x    SYSEXEC   LCLPRTRX     PRINT environment
.    SYSEXEC   MEMBERS      Memberlist to stack
.    SYSEXEC   PDSCOPY      Member-copy
.    SYSEXEC   PDSCOPYD     Member-copy
.    SYSEXEC   PRINTDS      (must be locally customized)
.    SYSEXEC   RUNDATA      Site-specific variables
.    SYSEXEC   SHOWDDNM     Valid DDNames
.    SYSEXEC   SHOWPARM     Additional datasets
.    SYSEXEC   SHOWTASK     Front end for task system
.    SYSEXEC   SMARCH       Identify archive datasets
x    SYSEXEC   SMENDV       Identify Endevor parms
x    SYSEXEC   SMMAP        Identify order of ENDV datasets
x    SYSEXEC   SMNDM        Identify NDM sites
.    SYSEXEC   SMPKG        Identify package components
.    SYSEXEC   SMPREF       Set default dataset prefix
.    SYSEXEC   SMULOG
.    SYSEXEC   TRAPOUT      Trap trace output
.    SYSEXEC   UPOE@$ST     Alter statistics

     Modification History
     19960124 fxc enable "F" and "T" actions for repopulating one member
                  to multiple others with stats... especially for
                  REXXSKEL;
     19960131 fxc always allocate SYSIN and SYSPRINT to DA(*) when no
                  longer required;
     19970604 fxc parse at l.567 missing comma; Les Koehler sez Don't
                  waste 72 bytes for a blank line (trim unused
                  comments); changed rcx to ndvrc in cz_invoke_endevor;
     19970829 ctl Call SMPREF to determine default prefix to search for
                  during an ACQUIRE.
     19970908 jpb Add "V" as an alternate action for browse/view.
     19971021 fxc only do memberlist once per dsn
     19980608 fxc DIAGNOSE
     19980618 fxc add <never_search> capability
     19991109 fxc upgrade from v.970818 to v.19991109; RXSKLY2K;
     20010816 fxc save from roll-target (not roll-source)
     20011010 fxc reset <never_search>; add concat-seq to table;
                  add <never_use_DD>
     20230411 fxc adjust HELP; update Impact Analysis
     20230709 fxc correct some HELP-panels
     20230723 fxc modernize logging protocol;
     20231008 fxc SHOWTASK was being called unconditionally when REPOP;
                  chg all sw. to sw.0;
     20231019 fxc display never_use_DD names;
     20240217 fxc add DDname to primary display;
     20240308 fxc fixed problem of TBMOD with wrong ddname;
     20240310 fxc IDENT; remove embedded assets from Impact Analysis
                  section;
     20240423 fxc DUMP_QUEUE quiet;
     20240513 fxc changed SYSPROC to SYSEXEC in I/A;
     20240610 fxc don't eliminate dups in BA;
     20240701 fxc correct UPOE name;
     20241102 fxc Use RUNDATA for local customization; cosmetics;
     20241104 fxc chg logdsn to @logdsn; chg log lrecl to 255;
     20250218 fxc add ZTDMARK at bottom of scroll

*/ arg argline
address ISPEXEC                        /* REXXSKEL ver.20240618      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc = Trace( "O" ); rc = trace(tv)
info   = parms                         /* to enable parsing          */

"CONTROL ERRORS RETURN"

call A_INIT                            /* call LA & build a list    -*/
call B_PROCESS_INPUTS                  /* of valid ddnames.  Load    */

"TBSTATS" showtbl "ROWCURR(ROWNUM)"
   if rownum > 0 then                  /* If there are rows in the   */
      call C_DISPLAY                   /* table then start the MAZE -*/
   else do
      zerrsm = "None Found"
      zerrlm = "No matches found for MEMBER LIST("strip(memlist)")",
               "and for DDNAME LIST("save_ddnames")"
      "SETMSG MSG(ISRZ002)"
      end                              /* else (rownun)              */

"TBEND" showtbl

if sw.0Keeplog then,
   call ZB_SAVELOG                     /*                           -*/
if \sw.nested then call DUMP_QUEUE 'quiet' /*                       -*/
exit                                   /*@ SHOWMEM                   */
/*
   Initialize variables, build qualifer arrays, create the temp table,
   build the mapping rules, and build array for endevor libs.
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address TSO

   nicknames = KEYPHRS(".PKGS")
   sw.0Keeplog = SWITCH( "LOG" )

   call A0_SETUP_LOG                   /*                           -*/
   ZTDMARK = "======  Bottom of data  ======"

   parse var info input_list           /* preserve info for later    */

   parse value "0 0 0 0 0 0 0 0 0 0 0"  with ,
                known_DSN.   seq.  ,
                .
   parse value "SHOW"Right(Time("S"),4,"#")  0      'efef'X  'ef'X  with ,
                showtbl                      endv.  xefef    xef         ,
                endv_list ,
                ddname.  ddnames  memlist  map.  mems.  dsns.  .

   parse value SMPREF() UserID()".ENDV" with, /*                    -*/
               pref  .
   logpref = "("BRANCH("ID")")"
   call ZL_LOGMSG( logpref "Using SMPREF" pref)

   never_use_dd = "SYSLBC ISPLLIB EDCHKDD ISPTLIB ISPTABL"
   call ZL_LOGMSG( logpref "Never Use DD:" never_use_dd )
   never_search = blockdss             /* Acquired from RUNDATA      */
   call ZL_LOGMSG( logpref "Never Search:" never_search )

   expose_list = " opts xef xefef dataset memname noupdt ndmsites "

   msg.0  = "Completed"
   msg.1  = "FAILED"
/*
   "NEWSTACK"
   "SMMAP"                             /*                           -*/
   pull endv_list
   do queued()                         /* ddname dsntest dsnprod     */
      pull ddname  map.ddname          /* may be more than 1 token   */
      call ZL_LOGMSG("SMMAP:" Left(ddname,8) Strip(map.ddname) )
   end                                 /* queued()                   */
   "DELSTACK"
*/
   do while endv_list <> ""            /* Turn on                    */
      parse var endv_list dsn endv_list
      endv.dsn = 1
   end

   address ISPEXEC

   "VGET UPDTTASK SHARED "
   parse value updttask 'N'  with  updttask  .
   "VPUT UPDTTASK SHARED "

   "VGET ZENVIR SHARED"                /* ISPF Version info          */

   zenvir     = Substr(zenvir,6,3)     /* ISPF 4.2MVS .......        */
   viewopt.0  = "BROWSE"               /* Get version number         */
   viewopt.1  = "VIEW"
   viewopt    = zenvir >  3.5          /* Browse or View?            */
   viewopt    = viewopt.viewopt

   "TBCREATE" showtbl "KEYS(DATASET MEMNAME DDNAME)",
             "NAMES(VV MM CREATED CHANGED TIME SIZE",
             "INIT MOD ID AL SEQ)",
             "NOWRITE REPLACE"
   "TBSORT"  showtbl "FIELDS(DDNAME,C,A , MEMNAME,C,A , SEQ,N,A)"

return                                 /*@ A_INIT                    */
/*
.  ----------------------------------------------------------------- */
A0_SETUP_LOG:                          /*@                           */
   if branch then call BRANCH
   address TSO

   msglim = SYSVAR( "SYSWTERM" ) - 12
   parse value "0 0 0 0 0" with,
                log#    log.  .
   parse value Date("S")  Time("S")  Time("N")  with,
               yyyymmdd   sssss      hhmmss  .
   hhmmss = Space( Translate( hhmmss,' ',':' ) ,0 )
   parse var yyyymmdd  4 yrdigit 5 mm 7 dd          /* 9 12 14 maybe */
   if Pos(yrdigit,"13579") > 0 then mm = mm + 12       /* mm=24      */
   logtag = Substr("ABCDEFGHIJKLMNOPQRSTUVWX",mm,1)    /* logtag=X   */
   subid  = logtag""dd""Left(  hhmmss,4 )              /* X141743  ? */
   vb4k.0    = "NEW CATALOG UNIT( SYSDA ) SPACE( 1 5 ) TRACKS",
               "RECFM( V B ) LRECL( 255 ) BLKSIZE( 0 )"
   vb4k.1    = "MOD"                   /* if it already exists...    */
   @logdsn = "@LOG."exec_name"."subid".LIST"

   logpref = "("BRANCH("ID")")"
   call ZL_LOGMSG( exec_name "started by" Userid()  yyyymmdd  hhmmss )
   call ZL_LOGMSG( logpref "Arg:" argline )

return                                 /*@ A0_SETUP_LOG              */
/*
   Build list of default and active DDNames.  Separate input parms
   into DDNames and members.  Build array indexed by DDName which
   contains the datasets to search for that DDName.
.  ----------------------------------------------------------------- */
B_PROCESS_INPUTS:                      /*@                           */
   if branch then call BRANCH
   address TSO

   call BA_ACTIVE_DDNAMES              /* sets valid_ddnames        -*/
   call BB_SPLIT_DDNAMES_FROM_MEMBERS  /*                           -*/

   logpref = "("BRANCH("ID")")"
   call ZL_LOGMSG( logpref "DDNames:" ddnames)
   do idx = 1 to Words(ddnames)        /* Append to array anything   */
      ddname = Word(ddnames,idx)       /* that is in SHOWPARM        */
      dsns.ddname = dsns.ddname SHOWPARM(ddname) /* get more DSNs   -*/
      logpref = "("BRANCH("ID")")"
      call ZL_LOGMSG( logpref ddname "DSNames:" dsns.ddname)
      call XT_TRIM_DSNLIST             /* remove duplicates         -*/
      call BX_GET_MEMS                 /*                           -*/
   end                                 /* idx                        */

   if Pos("*",memlist) > 0 then        /* Wilcard present            */
      call BC_WILDCARDS                /*                           -*/
   else
      call BD_MEMBER_SEARCH            /*                           -*/

   if nicknames = "" then nop
   else
      call BE_NICKNAMES

return                                 /*@ B_PROCESS_INPUTS          */
/*
   Create <valid_ddnames> to be used to verify the parameter string.
   SHOWDDNM provides any non-standard DDNames; LA provides the allocated
   DDNames and the DSNames that go with them.
.  ----------------------------------------------------------------- */
BA_ACTIVE_DDNAMES:                     /*@                           */
   ba_tv = Trace()                     /* what setting at entry ?    */
   if branch then call BRANCH
   address TSO

   "NEWSTACK"                          /* Call external routine to   */
   "SHOWDDNM"                          /* get list of valid ddnames -*/
   pull valid_ddnames
   logpref = "("BRANCH("ID")")"
   call ZL_LOGMSG( logpref "Valid DDNames:" valid_ddnames)
   "DELSTACK"

   "NEWSTACK"                          /* array indexed by ddname    */
                                       /* that contains all datasets */
   "LA (( STACK LIST  "                /* allocated to that ddname. -*/

   do queued()
      parse pull ddname ":" dsnames
      if Left(ddname,3) = "ISP" |,
         Left(ddname,4) = "SYS0" |,
         Left(ddname,4) = "SYSU" |,
         WordPos(ddname,never_use_DD) > 0 then iterate    /* ignore  */
      valid_ddnames = valid_ddnames ddname
                    /* If it's in <never_search>, drop from the list */
      token = ""                       /* init                       */
      do Words(dsnames)                /* every DSName               */
         parse value dsnames token   with  token dsnames
         if WordPos(token,never_search) > 0 then token = ""
         known_DSN.token = 1
      end
                                   $z$ = Trace("O"); $z$ = Trace(ba_tv)
      dsnames = Space(dsnames token,1) /* add last one back          */

      dsns.ddname   = Space(dsns.ddname   dsnames,1)
   end                                 /* queued                     */
                                   rc = Trace(ba_tv)
   "DELSTACK"

return                                 /*@ BA_ACTIVE_DDNAMES         */
/* Parse the main parameter string.  Any words which are in
   <valid_ddnames> are DDNames; everything else is a member name.  This
   might be a good place to call BE_ to attach package data.

.  NOTE :::  the code here requires that the caller specify ALL DDnames
   to be searched, including SYSPROC and SYSEXEC.  Failure to do so
   means the search is conducted ONLY in SYSPROC and SYSEXEC.
.  ----------------------------------------------------------------- */
BB_SPLIT_DDNAMES_FROM_MEMBERS:         /*@                           */
   if branch then call BRANCH
   address TSO

   do until input_list = ""            /* member names to search for.*/
       parse var input_list name input_list

       if Wordpos(name,valid_ddnames) > 0 then do
          if Wordpos(name,ddnames) = 0 then
             ddnames = ddnames name    /* Unique list of ddnames     */
          end                          /* Wordpos(name,valid_ddnames)*/
       else
          if Wordpos(name,memlist) = 0 then
             memlist = memlist name    /* Unique list of members     */

   end                                 /* until                      */

   if ddnames = "" then ddnames = "SYSEXEC SYSPROC"

   logpref = "("BRANCH("ID")")"
   call ZL_LOGMSG( logpref "Using DDNames:" ddnames )
   call ZL_LOGMSG( logpref "Seeking members:" memlist )

   save_ddnames = ddnames              /* may need it later          */

return                                 /*@ BB_SPLIT_DDNAMES_FROM_MEMBERS */
/*
   There is a wildcard.  Build the mems array which is indexed by DDName
   and dsn.  This will contain a list of the members for that dsn.
.  ----------------------------------------------------------------- */
BC_WILDCARDS:                          /*@                           */
   if branch then call BRANCH
   address TSO

   call BCA_FIND_MATCHES

return                                 /*@ BC_WILDCARDS              */
/*
   Wildcard characters have been found in member string.  Process each
   DDName, dataset and member list for matches.
.  ----------------------------------------------------------------- */
BCA_FIND_MATCHES:                      /*@                           */
   if branch then call BRANCH
   address TSO

   logpref = "("BRANCH("ID")")"
   call ZL_LOGMSG( logpref "Resolving wildcards" )
   do dd = 1 to Words(ddnames)         /* Process ddnames            */
      ddname = Word(ddnames,dd)

      do mem = 1 to Words(memlist)     /* Process member list        */
         tempname = Word(memlist,mem)  /* 1 if present, 0 if not     */
         wildcard = Pos("*",tempname) > 0

         if wildcard then do           /* is a wildcard              */
            lomask  = Translate(tempname,'00'X,"*")
            himask  = Translate(tempname,'ff'X,"*")
            lenmask = Length(tempname)
            end                        /* wildcard                   */

         do ii = 1 to Words(dsns.ddname)
            dataset  = Word(dsns.ddname,ii)
            templist = mems.dataset
            call BCAA_SEARCH           /*                           -*/
         end                           /* ii (Words(dsns.ddname)     */

      end                              /* mem = 1 to w(memlist)      */
   end                                 /* dd = 1 to w(ddnames)       */

return                                 /*@ BCA_FIND_MATCHES          */
/*
   Search through templist (member list of dsn) and look for match.
   If found then load the table.
.  ----------------------------------------------------------------- */
BCAA_SEARCH:                           /*@                           */
   if branch then call BRANCH
   address TSO

   if wildcard then
      do until templist = ""           /* Is a wildcard, check each  */
                                       /* member                     */
         parse var templist memname templist

         ckmem = Left(memname,lenmask)

         if BitAND(himask,ckmem) = BitOR(lomask,ckmem) then
            call ZL_LOAD_STATS         /*                           -*/

      end                              /* until                      */
   else
      if Wordpos(tempname,templist) > 0 then do /* not a wildcard    */
         memname = tempname            /* if the member is in list   */
         call ZL_LOAD_STATS            /* then load to table        -*/
         end                           /* Wordpos(tempname,...)      */

return                                 /*@ BCAA_SEARCH               */
/*
   There are no wildcards.  Process list of DDNames and members.
   Check if member exists in each dataset allocated to the DDName.
   If found then get the stats and load table.
.  ----------------------------------------------------------------- */
BD_MEMBER_SEARCH:                      /*@                           */
   if branch then call BRANCH
   address TSO

   do while ddnames <> ""
      parse var ddnames ddname ddnames

      do ii = 1 to Words(memlist)
         memname = Word(memlist,ii)
         call BZ_LOAD_HITS             /*                           -*/
      end                              /* ii = 1                     */

   end                                 /* until                      */

return                                 /*@ BD_MEMBER_SEARCH          */
/*
   Get package data from SMPKG consisting of DDName and members related
   to that DDName.
.  ----------------------------------------------------------------- */
BE_NICKNAMES:                          /*@                           */
   if branch then call BRANCH
   address TSO

   "NEWSTACK"
   "SMPKG" nicknames                   /*                            -*/

   logpref = "("BRANCH("ID")")"
   call ZL_LOGMSG( logpref "SMPKG" nicknames)

   do queued()
      pull ddname mems
      logpref = "("BRANCH("ID")")"
      call ZL_LOGMSG( logpref "SMPKG:" ddname mems)
      if Wordpos(ddname,ddnames) = 0 then do
         ddnames = ddnames ddname
         dsns.ddname = dsns.ddname SHOWPARM(ddname) /*              -*/
         call XT_TRIM_DSNLIST          /*                           -*/
         call BX_GET_MEMS              /*                           -*/
         end
      do while mems <> ""
         parse var mems memname mems
         call BZ_LOAD_HITS             /*                           -*/
      end                              /* while mems                 */
   end                                 /* queued()                   */
   "DELSTACK"

return                                 /*@ BE_NICKNAMES              */
/*
   Get the memberlist(s) for this DDName and store as <mems.dsn>
.  ----------------------------------------------------------------- */
BX_GET_MEMS:                           /*@                           */
   bx_tv = Trace()                     /* what setting at entry ?    */
   if branch then call BRANCH
   address TSO

   logpref = "("BRANCH("ID")")"
   wrkddn = ddname":"
   do ii = 1 to Words(dsns.ddname)
      dsn = Word(dsns.ddname,ii)

      if mems.dsn = "" then do
         if Sysdsn("'"dsn"'") = "OK" then do
            "NEWSTACK"
            "MEMBERS '"dsn"' ((STACK LINE ALIAS"
            pull mems.dsn
            "DELSTACK"
            end
         else iterate

         if mems.dsn = "<EMPTY>" then nop; else,
            do
            if sw.0diagnose then say,
               "call ZL_LOGMSG(" Left(wrkddn,11) dsn Words(mems.dsn) ,
                           "members )"
            call ZL_LOGMSG( logpref dsn":" mems.dsn)
            wrkddn = ""
            end
         end                           /*  mems.dsn = ""             */
   end                                 /*  ii                        */

return                                 /*@ BX_GET_MEMS               */
/*
   Given a DDName and a membername, examine all datasets within that
   DDName for the member.  NOTE that this search is specific to a
   DDName.  For any found, load to the table.
.  ----------------------------------------------------------------- */
BZ_LOAD_HITS:                          /*@                           */
   if branch then call BRANCH
   address TSO

   do bz = 1 to Words(dsns.ddname)     /* Process each dataset       */
      dataset = Word(dsns.ddname,bz)
      if Wordpos(memname,mems.dataset) > 0 then
         call ZL_LOAD_STATS            /* found a hit then load tbl -*/
   end                                 /* bz                         */

return                                 /*@ BZ_LOAD_HITS              */
/*
   Beginning of the maze.  Display the table, if any rows are
   selected then call PROCESS....
.  ----------------------------------------------------------------- */
C_DISPLAY:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "TBTOP" showtbl

   parse value "" with to_list from_list repop_member zerrlm

   call C0_ISPF_PROLOG                 /*                           -*/
   do forever
      "TBDISPL" showtbl "PANEL("nqa_panel")"
      if rc > 4 then leave
      if zcmd <> "" then do            /*                            */
         call CZ_ZCMD                  /*                           -*/
         iterate
         end                           /* zcmd                       */

      if ztdsels > 0 then
         call CA_PROCESS_SELECTIONS    /*                           -*/

      if to_list = "" | from_list = "" then nop; else,
         call CB_REPOPULATE            /* do REPOPs last            -*/

      parse value "" with to_list from_list repop_member

   end                                 /* forever                    */
   call CZ_ISPF_EPILOG                 /*                           -*/

return                                 /*@ C_DISPLAY                 */
/*
   LIBDEF into place at the topmost position all the libraries created
   during DEIMBED.
.  ----------------------------------------------------------------- */
C0_ISPF_PROLOG:                        /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   call DEIMBED                        /*                           -*/
   dd = ""
   do Words(ddnlist)                   /* each LIBDEF DD             */
      parse value ddnlist dd  with  dd ddnlist
      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */
      "LIBDEF  ISP"dd "LIBRARY  ID("$ddn") STACK"
   end
   ddnlist = ddnlist dd

return                                 /*@ C0_ISPF_PROLOG            */
/*
   Process each row selected.  We know that at least 1 row has been
   selected.
.  ----------------------------------------------------------------- */
CA_PROCESS_SELECTIONS:                 /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   do ztdsels
      "CONTROL DISPLAY SAVE"

      parse value "0               0"                          with,
                  sw.0Error_found sw.0Stop zerrsm  zerrlm  .

      select
         when action = "A" then        /* Acquire                    */
            call CAA_ACQUIRE           /*                           -*/

         when action = "B" then        /* Browse/View                */
            viewopt "DATASET('"dataset"("memname")'"

         when action = "C" then        /* Copy                       */
            call CAC_COPY              /*                           -*/

         when action = "D" then        /* Delete                     */
            call CAD_DELETE            /*                           -*/

         when action = "E" then do     /* Edit - reload stats        */
            "EDIT  DATASET('"dataset"("memname")')"
             if rc = 0 then
                call ZL_LOAD_STATS     /* if changed then reload    -*/
             end                       /* action = "E"               */

         when action = "F" then do     /* "FROM" dataset-name        */
            from_list = from_list dataset
            repop_member = memname
            popvv      = vv
            popmm      = mm
            popcreated = created
            popchanged = changed
            poptime    = time
            popsize    = size
            popinit    = init
            popmod     = mod
            popid      = id
            end

         when action = "I" then,       /* Incompatible DCB copy      */
            call CAI_COPYD             /*                           -*/

         when action = "L" then        /* View all members           */
/*          viewopt "DATASET('"dataset"')"    */
            address TSO "%MEMLIST '"dataset"' V "

         when action = "M" then        /* Edit dataset               */
/*          "EDIT   DATASET('"dataset"')"     */
            address TSO "%MEMLIST '"dataset"' E "

         when action = "P" then        /* Print                      */
            call CAP_PRINT             /*                           -*/

         when action = "R" then        /* Roll                       */
            call CAR_ROLL              /*                           -*/

         when action = "T" then,       /* "TO" dataset-name          */
            if \endv.dataset then,     /*  non-ENDV DS               */
               to_list = to_list dataset

         when action = "U" then
            address TSO "EXEC '"icebase"(UPOE@$ST)' '"showtbl,
               memname dataset vv mm created changed time size,
               init mod id ddname "((TRACE" tv "'"

         when action = "V" then        /* View this member           */
            viewopt "DATASET('"dataset"("memname")'"

         otherwise nop

      end                              /* select                     */

      "CONTROL DISPLAY RESTORE"

      if ztdsels > 1 then
         "TBDISPL" showtbl

      if sw.0Error_found then
         "SETMSG MSG(ISRZ002)"

   end                                 /* ztdsels                    */

   action = ""

return                                 /*@ CA_PROCESS_SELECTIONS     */
/*
   Determine if dataset is an Endevor managed dataset.  If so, then
   acquire must be done via Endevor.  Determine the approriate routine
   to call.
.  ----------------------------------------------------------------- */
CAA_ACQUIRE:                           /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   parse var dsns.ddname . (pref) qual .

   if qual = "" then todsn = Word(dsns.ddname,1)
   else              todsn = pref||qual

   tomem   = memname
   ndvactn = "ACQUIRE"

   call CAAB_ACQUIRE                   /*                           -*/

   if sw.0Error_found then return
   if sw.0Stop then return

   if updttask = "Y" then              /* Update task system         */
      call SHOWTASK("FROMDSN" dataset "FROMMEM" memname,
                      "TODSN" todsn     "TOMEM" tomem "ACTION" ndvactn)

   parse value todsn       tomem     ddname.todsn  ddname  with,
               dataset     memname   ddname      .
   "TBMOD" showtbl                     /* Add to bottom of table     */

return                                 /*@ CAA_ACQUIRE               */
/*
   Acquire for non-Endevor managed datasets.  This is done via
   IEBCOPY.
.  ----------------------------------------------------------------- */
CAAB_ACQUIRE:                          /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   zwinttl = "Acquire" memname

   call CZ_DISPLAY_WINDOW "SMACQUR"    /*                           -*/
                                    if sw.0Stop then return
   call CZ_CONFIRM todsn tomem         /* Confirm overlay of code   -*/
                                    if sw.0Stop then return
   call CZ_IEBCOPY dataset memname todsn tomem   /* do copy         -*/
                                    if sw.0Error_found then return

return                                 /*@ CAAB_ACQUIRE              */
/*
   Copy a member to up to three different dataset-members using
   IEBCOPY.
.  ----------------------------------------------------------------- */
CAC_COPY:                              /*@                           */
   if branch then call BRANCH
   address ISPEXEC
                                       /*  Can copy mutilple dsns    */
   "VGET (OUTDSN1 OUTDSN2 OUTDSN3 UPDTTASK) PROFILE"

   do ii = 1 to 4                      /* Set equal to memname       */
      rc = Value('newmem'||ii,memname)
   end

   savedsn = CZ_ARCHIVE_DSNAME(ddname) /* Build save ds name        -*/

   zwinttl = "COPY" memname

   call CZ_DISPLAY_WINDOW "SMCOPY"     /*                           -*/
                                    if sw.0Stop then return

   "NEWSTACK"

   queue outdsn1 newmem1               /* load with datasets to      */
   queue outdsn2 newmem2               /* copy.  They may or may not */
   queue outdsn3 newmem3               /* be blank                   */

   if backup = "Y" then
      queue savedsn newmem4

   do queued()
      pull outdsn newmem .
      if newmem = "" then iterate
                                       /*  Check if overlay          */
      call CZ_CONFIRM outdsn newmem    /* Confirm overlay of code   -*/
      if sw.0Stop then iterate

      call CZ_IEBCOPY dataset memname outdsn newmem  /*             -*/

      if sw.0Error_found then
         "SETMSG MSG(ISRZ002)"
      else do
         if updttask = "Y" then        /* Update task system         */
            call SHOWTASK("FROMDSN" dataset "FROMMEM" memname,
                            "TODSN" outdsn    "TOMEM" newmem "ACTION COPY")
         parse value outdsn   newmem   ddname.outdsn  ddname  with,
                     dataset  memname  ddname  .
         "TBMOD" showtbl               /* update table               */
         end
   end                                 /* queued()                   */

   "DELSTACK"

return                                 /*@ CAC_COPY                  */
/*
   Delete a member.  Endevor must be used if dsn is a Endevor managed
   dataset.
.  ----------------------------------------------------------------- */
CAD_DELETE:                            /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   call ZD_PDS_DELETE "'"dataset"'" memname
   if sw.0Error_found then nop
   else
      "TBDELETE" showtbl            /* delete row from tbl        */

return                                 /*@ CAD_DELETE                */
/*
   Use PDSCOPYD to move text between PDSs with incompatible DCBs.
.  ----------------------------------------------------------------- */
CAI_COPYD:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC
                                       /*  Can copy mutilple dsns    */
   "VGET (OUTDSN1 OUTDSN2 OUTDSN3 UPDTTASK) PROFILE"

   do ii = 1 to 4                      /* Set equal to memname       */
      rc = Value('newmem'||ii,memname)
   end

   savedsn = CZ_ARCHIVE_DSNAME(ddname) /* Build save ds name        -*/

   zwinttl = "PDSCOPYD" memname "(incompatible DCB)"

   call CZ_DISPLAY_WINDOW "SMCOPY"     /*                           -*/
                                    if sw.0Stop then return

   "NEWSTACK"

   queue outdsn1 newmem1               /* load with datasets to      */
   queue outdsn2 newmem2               /* copy.  They may or may not */
   queue outdsn3 newmem3               /* be blank                   */

   if backup = "Y" then
      queue savedsn newmem4

   do queued()
      pull outdsn newmem .
      if newmem = "" then iterate
                                       /*  Check if overlay          */
      call CZ_CONFIRM outdsn newmem    /* Confirm overlay of code   -*/
      if sw.0Stop then iterate

      call CZ_PDSCOPYD dataset memname outdsn newmem /*             -*/

      if sw.0Error_found then
         "SETMSG MSG(ISRZ002)"
      else do
         if updttask = "Y" then        /* Update task system         */
            call SHOWTASK("FROMDSN" dataset "FROMMEM" memname,
                            "TODSN" outdsn    "TOMEM" newmem "ACTION COPY")
         parse value outdsn   newmem   ddname.outdsn  ddname  with,
                     dataset  memname  ddname  .
         "TBMOD" showtbl               /* update table               */
         end
   end                                 /* queued()                   */

   "DELSTACK"

return                                 /*@ CAI_COPYD                 */
/*
   Print member.  Display panel allowing user to specify parms, such
   as copies and printer destination.
.  ----------------------------------------------------------------- */
CAP_PRINT:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "VGET (DEST) SHARED"

   zwinttl = "Print Confirmation"

   call CZ_DISPLAY_WINDOW "SMPRINTN"   /*                           -*/
                                    if sw.0Stop then return
   "VPUT (DEST) SHARED"

   if noupdt then return

   copy = Max("1",copy)                /* Print member               */

   address TSO

   "PRINTDS DATASET('"dataset"("memname")'", /* get ds,mem,dest,etc -*/
               "CLASS("prcls")  DEST("dest")",
               "COPIES("copy")" prtopts

return                                 /*@ CAP_PRINT                 */
/*
   Roll member to next stage.  If dataset is Endevor-managed then
   must perform an ADD or a MOVE.  If not then use IEBCOPY.  Roll
   is a two step process (only perform one step at a time).

   Step 1:  user lib to TEST lib
   Step 2:  TEST lib to PROD lib
.  ----------------------------------------------------------------- */
CAR_ROLL:                              /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "VGET (UPDTTASK) PROFILE"

   parse value updttask "N" with,
               updttask  .

   savedsn = CZ_ARCHIVE_DSNAME(ddname) /*                           -*/

   parse var map.ddname testdsn cnfgdsn .

   if dataset = cnfgdsn then do
      zerrsm = "Already in Production" /*  active                    */
      zerrlm = dataset "and" cnfgdsn "match.  Can't roll PROD to PROD."
      sw.0Error_found = 1
      return
      end                              /* dataset = cnfgdsn          */

   if dataset = testdsn then           /* Roll from T to P           */
      push cnfgdsn  "MOVE    N       2"
   else                                /* Roll to Prod               */
      push testdsn  "ADD     N       1"

    pull   todsn    ndvactn  backup  stage  .

   tomem   = memname

   call CARB_ROLL                      /*                           -*/

   if sw.0Stop       then return
   if sw.0Error_found then return

   call CARC_LOG_ROLL_ACTION           /*                           -*/

   if sw.0DBEHIND then                 /* Delete behind requested    */
      "TBDELETE" showtbl               /* delete from table          */

   if updttask = "Y" then              /* Update task system         */
      call SHOWTASK("FROMDSN" dataset "FROMMEM" memname,
                      "TODSN" todsn     "TOMEM" tomem "ACTION" ndvactn)

   parse value todsn    tomem    ddname.todsn  ddname  with,
               dataset  memname  ddname  .

   "TBMOD" showtbl

return                                 /*@ CAR_ROLL                  */
/*
   Display window that shows copy stats
.  ----------------------------------------------------------------- */
CARAA_IEBCOPY_WINDOW:                  /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   var = sw.0Error_found

   zwinttl = "IEBCOPY" msg.var "RC("rcx")"

   popmsg1 = "From:" indsn
   popmsg2 = "Mem :" inmem
   popmsg3 = "TO  :" copy2dsn
   popmsg4 = "Mem :" copy2mem

   if sw.0Error_found then nop
   else
      "CONTROL DISPLAY LOCK"

   call CZ_DISPLAY_WINDOW "POP50BY4"   /*                           -*/

return                                 /*@ CARAA_IEBCOPY_WINDOW      */
/*
   Perform the non-Endevor roll using IEBCOPY.
.  ----------------------------------------------------------------- */
CARB_ROLL:                             /*@                           */
   if branch then call BRANCH
   address TSO

   type    = ddname                    /* Needed for call to SMULOG  */
   zwinttl = "Roll -" memname

   call CZ_DISPLAY_WINDOW "SMROLL"     /*                           -*/
                                    if sw.0Stop then return

   sw.0SAVE    = backup = "Y" /* | ndvactn = "ADD" */
   sw.0DBEHIND = behind = "Y"

   call CZ_CONFIRM todsn tomem         /* Confirm overlay of code   -*/
                                    if sw.0Stop then return

   if sw.0SAVE then do
      call CZ_IEBCOPY todsn   tomem   savedsn tomem /*              -*/
      call CARAA_IEBCOPY_WINDOW        /*                           -*/
      end                              /* sw.0SAVE                   */

   if sw.0Error_found then return

   call CZ_IEBCOPY dataset memname todsn tomem

   if sw.0Error_found then return

   if sw.0DBEHIND then
      call ZD_PDS_DELETE "'"dataset"'" memname
      /* should probably also TBDELETE ? */

return                                 /*@ CARB_ROLL                 */
/*
   Track date and time of ROLL
.  ----------------------------------------------------------------- */
CARC_LOG_ROLL_ACTION:                  /*@                           */
   if branch then call BRANCH
   address TSO

   parmlist = "ACTION" Left(ndvactn,4) "ELEMENT" memname,
              "TYPE" type "VERSION" vv "LEVEL" mm "CREATE" created,
              "CHANGE" changed "SIZE" size "INIT" init "MOD" mod,
              "ID" id

    "NEWSTACK"
    "SMULOG" parmlist                  /*                            -*/
    "DELSTACK"

return                                 /*@ CARC_LOG_ROLL_ACTION      */
/*
   The user has entered one (and ONLY ONE) "F" action and one or more
   "T" actions on the panel.  The DSNs have been collected into
   <from_list> and <to_list>.  IEBCOPY <repop_member> from the
   one-and-only "FROM" DSN to each of the "TO" DSNs.
.  ----------------------------------------------------------------- */
CB_REPOPULATE:                         /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   if Words(from_list) <> 1 then,
      zerrlm = zerrlm "One and only one 'From' token may be specified. "
   if Words(to_list)  = 0 then,
      zerrlm = zerrlm "At least one 'To' token must be specified. "
   if zerrlm <> "" then do
      sw.0Error_found = 1
      return
      end

   parse value from_list with from_list .

   do while to_list <> ""
      parse var to_list  outdsn to_list
      call CZ_IEBCOPY from_list repop_member outdsn repop_member /* -*/
      if sw.0Error_found then          /* Copy failed                */
         "SETMSG MSG(ISRZ002)"
      else do
         if updttask = "Y" then        /* Update task system         */
            call SHOWTASK("FROMDSN" from_list "FROMMEM" repop_member,
                          "TODSN" outdsn     "TOMEM" repop_member,
                          "ACTION REPOP")
         parse value outdsn   repop_member  ddname.outdsn  ddname  with,
                     dataset  memname       ddname   .
         vv           = popvv
         mm           = popmm
         created      = popcreated
         changed      = popchanged
         time         = poptime
         size         = popsize
         init         = popinit
         mod          = popmod
         id           = popid
         "TBMOD" SHOWTBL               /* Add to bottom of table     */
         logpref = "("BRANCH("ID")")"
         call ZL_LOGMSG( logpref "TBMOD" showtbl "with values:",
              "DSN="dataset "MEM="memname "DD="ddname ,
              "Ver="vv "Mod="mm "Credate="created "Chgdate="changed,
              "Time="time "Size="size "Init="init "Mod="mod,
              "ID="id  "AL="al "Seq="seq )
         end                           /* else (\sw.0Error_found)    */

    end                                /* while                      */

return                                 /*@ CB_REPOPULATE             */
/*
   Build the archive dataset name.  SMARCH will return by DDName the
   dataset to be used as the archive dataset.
.  ----------------------------------------------------------------- */
CZ_ARCHIVE_DSNAME:                     /*@                           */
   if branch then call BRANCH
   address TSO
   arg ddname .

   savedsn = SMARCH(ddname)            /*                           -*/

return(savedsn)                        /*@ CZ_ARCHIVE_DSNAME         */
/*
   If a member will be overlaid then display a window requesting
   confirmation of the overlay.  Turn switch on overlay was not
   verified.
.  ----------------------------------------------------------------- */
CZ_CONFIRM:                            /*@                           */
   if branch then call BRANCH
   address TSO
   arg olaydsn olaymem .

   if Sysdsn("'"olaydsn"("olaymem")'") <> "OK" then return

   zwinttl = "Overlay Confirmation"
   call CZ_DISPLAY_WINDOW "SMCONFRM"   /*                           -*/
   sw.0Stop = confirm = "N"

return                                 /*@ CZ_CONFIRM                */
/*
.  ----------------------------------------------------------------- */
CZ_DISPLAY_WINDOW:                     /*@                           */
   if branch then call BRANCH
   address ISPEXEC
   arg pnl row column .

   parse value row 10 'ef'X column 10 with ,
               row .  'ef'X column .

   "ADDPOP ROW("row") COLUMN("column")"
   "DISPLAY PANEL("pnl")"
   rcx = rc
   "REMPOP ALL"

   sw.0Stop = rcx > 4

return                                 /*@ CZ_DISPLAY_WINDOW         */
/*
   Copy a member using IEBCOPY.  At some sites, IEBCOPY is not usable
   in the TSO foreground; use PDSCOPYD.
.  ----------------------------------------------------------------- */
CZ_IEBCOPY:                            /*@                           */
   if branch then call BRANCH
   address TSO
   arg indsn inmem copy2dsn copy2mem .

   call CZ_PDSCOPYD indsn inmem copy2dsn copy2mem .          /*      -*/

return                                 /*@ CZ_IEBCOPY                */
   parmlist = "FROM" indsn "TO" copy2dsn "MEMBER" inmem "AS" copy2mem

   rcx      = PDSCOPY(parmlist)        /*                           -*/

   sw.0Error_found = rcx < 0 | rcx > 4

   if sw.0Error_found then do
      zerrsm = "Copy Failed"
      zerrlm = "IEBCOPY failed with RC="rcx,
               "Unable to copy" indsn"("inmem") to" copy2dsn"("copy2mem")."
      end
/*
   Use PDSCOPYD to copy to an incompatible DCB.
.  ----------------------------------------------------------------- */
CZ_PDSCOPYD:                           /*@                           */
   if branch then call BRANCH
   address TSO
   arg indsn inmem copy2dsn copy2mem .

   parmlist = "FROMDS '"indsn"' TODS '"copy2dsn"'",
              "FROMMBR" inmem "TOMBR" copy2mem

   rcx      = PDSCOPYD(parmlist)       /*                           -*/

   sw.0Error_found = rcx < 0 | rcx > 4

   if sw.0Error_found then do
      zerrsm = "Copy Failed"
      zerrlm = "PDSCOPYD failed with RC="rcx,
               "Unable to copy" indsn"("inmem") to" copy2dsn"("copy2mem")."
      logpref = "("BRANCH("ID")")"
      call ZL_LOGMSG( logpref zerrlm)
      end

return                                 /*@ CZ_PDSCOPYD               */
/*
   ZCMD was populated.  Process the command text.
.  ----------------------------------------------------------------- */
CZ_ZCMD:                               /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   parse var zcmd verb text .
   select
      when verb = "SORT" then do
         sortspec    = ""
         varn.       = "?"
         varn.MEMBER = "MEMNAME"
         varn.DDNAME = "DDNAME"
         varn.DSN    = "DATASET"
         do while text <> ""
            parse var text fldspec text
            parse var fldspec  fldn "," fldt "," fldd .
            parse value fldt "C"  with fldt .
            parse value fldd "A"  with fldd .
            sortspec = sortspec varn.fldn fldt fldd
         end
         sortspec = Space(sortspec,1)
         sortspec = Translate(sortspec,","," ")
         "TBSORT" showtbl "FIELDS("sortspec")"
         end                           /* SORT                       */
      otherwise nop
   end                                 /* select                     */

return                                 /*@ CZ_ZCMD                   */
/*
   Disconnect and free any LIBDEFs created by DEIMBED
.  ----------------------------------------------------------------- */
CZ_ISPF_EPILOG:                        /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   dd = ""
   do Words(ddnlist)                   /* each LIBDEF DD             */
      parse value ddnlist dd  with  dd ddnlist
      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */
      "LIBDEF  ISP"dd
      address TSO "FREE  FI("$ddn")"
   end
   ddnlist = ddnlist dd

return                                 /*@ CZ_ISPF_EPILOG            */
/*
   Retrieve the ISPF stats and add to table.
.  ----------------------------------------------------------------- */
ZL_LOAD_STATS:                         /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   if Right(memname,3) = "(*)" then do /* it's an alias              */
      logpref = "("BRANCH("ID")")"
      parse var memname   memname "("
      al   = "(alias)"
      seq  = seq.dataset               /* concatenation sequence     */
      cmd = "TBMOD" showtbl "ORDER"
      (cmd)
      call ZL_LOGMSG( logpref cmd "RC="rc ,
                      "DS="dataset "Mbr="memname "DD="ddname )
      al   = ""
      return                           /* there are no stats         */
      end                              /* alias                      */

   parse value "" with ,
               zlcdate  zlmdate  zlmtime  zlcnorc  zlinorc,
               zlc4date zlm4date zlmnorc  zluser  zlvers  zlmod  .

   "LMINIT  DATAID(BASEID) DATASET('"dataset"')"
   if rc > 0 then do
      zerrlm = exec_name "("BRANCH("ID")")",
               zerrlm
      address ISPEXEC "SETMSG  MSG(ISRZ002)"
      sw.0error_found = 1 ; return
      end
   "LMOPEN  DATAID("baseid")"
   if rc > 0 then do
      zerrlm = exec_name "("BRANCH("ID")")",
               zerrlm
      address ISPEXEC "SETMSG  MSG(ISRZ002)"
      sw.0error_found = 1
      end
   "LMMFIND DATAID("baseid") MEMBER("memname") STATS(YES)"
   if rc > 0 & \sw.0error_found then do
      zerrlm = exec_name "("BRANCH("ID")")",
               zerrlm
      address ISPEXEC "SETMSG  MSG(ISRZ002)"
      sw.0error_found =  1
      end
   "LMCLOSE DATAID("baseid")"
   "LMFREE  DATAID("baseid")"
   if sw.0error_found then return

   parse value zlc4date zlm4date zlmtime  zlcnorc  zlinorc  zlmnorc,
                 zluser  zlvers  zlmod  with,
               created  changed  time     size     init     mod ,
                 id      vv      mm  .

   seq     = seq.dataset               /* concatenation sequence     */
   "TBMOD" showtbl "ORDER"
                                       /*  Clear out for next time   */
   parse value "" with,
               created  changed  time  size  init  mod  id  vv  mm  .

return                                 /*@ ZL_LOAD_STATS             */
/*
   At some sites, PDS has been disabled and cannot be used to delete
   members as SHOWMEM wants.  Since SHOWMEM must run as an ISPF
   dialog, the LM functions can handle the task almost as well.
.  ----------------------------------------------------------------- */
ZD_PDS_DELETE:                         /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   arg dsn mem .

   "LMINIT  DATAID(delid) DATASET("dsn")  ENQ(EXCLU)"
   if rc > 0 then do
      zerrsm = "LMINIT failed"
      if Symbol(zerrlm) = "LIT" then,
         zerrlm = "No additional diagnostics produced."
      zerrlm = exec_name "("BRANCH("ID")")",
               zerrlm
      address ISPEXEC "SETMSG  MSG(ISRZ002)"
      sw.0Error_found =  1 ; return
      end
   "LMOPEN  DATAID("delid")   OPTION(OUTPUT)"
   if rc > 0 then do
      zerrsm = "LMOPEN failed"
      if Symbol(zerrlm) = "LIT" then,
         zerrlm = "No additional diagnostics produced."
      zerrlm = exec_name "("BRANCH("ID")")",
               zerrlm
      address ISPEXEC "SETMSG  MSG(ISRZ002)"
      sw.0Error_found =  1
      end
   else,
   "LMMDEL  DATAID("delid")   MEMBER("mem")"
   if rc > 0 then do
      zerrsm = "LMMDEL failed"
      if Symbol(zerrlm) = "LIT" then,
         zerrlm = "No additional diagnostics produced."
      zerrlm = exec_name "("BRANCH("ID")")",
               zerrlm
      address ISPEXEC "SETMSG  MSG(ISRZ002)"
      sw.0Error_found =  1
      end
   "LMCLOSE DATAID("delid")"
   if rc > 0 then do
      zerrsm = "LMCLOSE failed"
      if Symbol(zerrlm) = "LIT" then,
         zerrlm = "No additional diagnostics produced."
      zerrlm = exec_name "("BRANCH("ID")")",
               zerrlm
      address ISPEXEC "SETMSG  MSG(ISRZ002)"
      sw.0Error_found =  1
      end
   "LMFREE  DATAID("delid")"

return                                 /*@ ZD_PDS_DELETE             */
/*     This old code may work for you...                              */
   address TSO
   arg dsn mem .

   xx = Outtrap("PDS.")
       "PDS" dsn "DELETE" mem
   xx = Outtrap("OFF")

   sw.0Error_found = rc > 4

   if sw.0Error_found then do
      zerrsm = "Delete Failed"
      zerrsm = "PDS Delete of" dsn"("mem") failed with RC="rc
      end                              /* sw.0Error_found            */
/*
   Called after the dsns.ddname is modified by a call to SHOWPARM.
   SHOWPARM may add redundant dataset names to the list; remove
   them.  This is done by clipping a dsn off the front of the list
   and searching the remainder for a match.
.  ----------------------------------------------------------------- */
XT_TRIM_DSNLIST: Procedure expose,     /*@                           */
   (tk_globalvars) (expose_list) dsns. ddname ddname.
   if branch then call BRANCH
   address TSO

   parse value "0"     with xpt  temp  .
   do while dsns.ddname <> ""
      parse var dsns.ddname  dsn  dsns.ddname
      temp  = temp dsn
      ddname.dsn = ddname              /* which DD owns this DS ?    */
      xpt = xpt + 1                    /* bump                       */
      seq.dsn   = xpt                  /* concatenation sequence     */
      do until dwp = 0
         dwp = Wordpos(dsn,dsns.ddname)
         if dwp > 0 then dsns.ddname = Delword(dsns.ddname,dwp,1)
      end
   end
   dsns.ddname = Space(temp,3)

return                                 /*@ XT_TRIM_DSNLIST           */
/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   address TSO

   parse value "SMHELP" with zerrhm .
/*
   ndmsites = SMNDM()                  /*                            -*/
   ndmsites = Delword( ndmsites, Wordpos( node,ndmsites ),1 )
*/
   "NEWSTACK"
   "RUNDATA READ  TBLKEY SHOWMEM "     /* sets multiple vars         */
   do queued()                         /* return from RUNDATA        */
      pull tag tagval
      if tag = "<ERROR>" then do
         sw.0Error_Found = 1
         "DELSTACK"
         say tag tagval
         return
         end
      tagval  = Space( tagval,1 )
      @z   = Value( tag,tagval )       /* tag <-- tagval             */
   end                                 /* queued                     */
   if Symbol( 'base' )     = 'LIT' |,
      Symbol( 'blockdss' ) = 'LIT' then do
      helpmsg = "RUNDATA did not supply a required value. ",
                "See the installation instructions regarding",
                "the RUNDATA table and correct it as",
                "specified before proceeding. "
      say helpmsg
      exit
      end
   "DELSTACK"
   icebase   = base
   panel.0   = "SHOWMEM"
   panel.1   = "SHOWMEM#"

   "NEWSTACK"
   "EXEC '"icebase"(ICEUSER)'" ; pull power_usr     /*    -*/
   "DELSTACK"

   is_ok = Wordpos( UserID(),power_usr ) > 0
   nqa_panel = panel.is_ok

   sw.0Diagnose  = SWITCH( "DIAGNOSE" ) | monitor
   monitor       = sw.0Diagnose         | monitor

return                                 /*@ LOCAL_PREINIT             */
/* Subroutines below LOCAL_PREINIT are not seen by SHOWFLOW           */
/*
   Parse out the embedded components at the back of the source code.
.  ----------------------------------------------------------------- */
DEIMBED: Procedure expose,             /*@                           */
   (tk_globalvars)  ddnlist  $ddn.  daid.

   address TSO

   fb80po.0  = "NEW UNIT(VIO) SPACE(5 5) TRACKS DIR(40)",
                   "RECFM(F B) LRECL(80) BLKSIZE(0)"
   parse value ""   with  ddnlist $ddn.  daid.

   lastln   = sourceline()
   currln   = lastln                   /*                            */
   if Left(sourceline(currln),2) <> "*/" then return

   currln = currln - 1                 /* previous line              */
   "NEWSTACK"
   address ISPEXEC
   do while sourceline(currln) <> "/*"
      text = sourceline(currln)        /* save with a short name !   */
      if Left(text,3) = ")))" then do  /* package the queue          */
         parse var text ")))" ddn mbr .   /* PLIB PANL001  maybe     */
         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */
            ddnlist = ddnlist ddn      /* keep track                 */
            $ddn = ddn || Random(999)
            $ddn.ddn = $ddn
            address TSO "ALLOC FI("$ddn")" fb80po.0
            "LMINIT DATAID(DAID) DDNAME("$ddn")"
            daid.ddn = daid
            end
         daid = daid.ddn
         "LMOPEN DATAID("daid") OPTION(OUTPUT)"
         do queued()
            parse pull line
            "LMPUT DATAID("daid") MODE(INVAR) DATALOC(LINE) DATALEN(80)"
         end
         "LMMADD DATAID("daid") MEMBER("mbr")"
         "LMCLOSE DATAID("daid")"
         end                           /* package the queue          */
      else push text                   /* onto the top of the stack  */
      currln = currln - 1              /* previous line              */
   end                                 /* while                      */
   address TSO "DELSTACK"

return                                 /*@ DEIMBED                   */
/*
.  ----------------------------------------------------------------- */
ZB_SAVELOG:                            /*@                           */
   if branch then call BRANCH
   address TSO

   if Symbol("LOG#") = "LIT" then return          /* not yet set     */

   "ALLOC FI( $LOG ) DA( "@logdsn" ) REU" vb4k.0
   "EXECIO" log# "DISKW $LOG (STEM LOG. FINIS"
   "FREE  FI($LOG)"

return                                 /*@ ZB_SAVELOG                */
/*
.  ----------------------------------------------------------------- */
ZL_LOGMSG: Procedure expose,           /*@                           */
   (tk_globalvars)  log. log#  msglim
   rc = Trace("O")
   address TSO

   parse arg msgtext

   /* for making the msgline always reasonably short:                */
   do while Length(msgtext) > msglim
      pt    = LastPos(" ",msgtext,msglim)
      slug  = Left(msgtext,pt)
      if monitor then say,
         slug
      parse value  log#+1  slug        with,
                   zz      log.zz    1  log#   .
      msgtext = "       "Substr(msgtext,pt)
   end                                 /* while msglim               */

   parse value  log#+1  msgtext     with,
                zz      log.zz    1  log#   .

   if monitor then say,
      msgtext

return                                 /*@ ZL_LOGMSG                 */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR"
if helpmsg <> "" then do ; say helpmsg;
   say "HELP not available for SHOWMEM"; end
ex_nam = Left(exec_name,8)             /* predictable size           */

say "  "ex_nam"      provides a selectable list of the components specified or "
say "                implied.                                                  "
say "                                                                          "
say "  Syntax:   "ex_nam"  cmp-list                                            "
say "                      .PKGS .. pkg-list ..                                "
say "                      LOG                                                 "
say "                 ((   DIAGNOSE                                            "
say "                                                                          "
say "            cmp-list  is a blank delimited list of the components to be   "
say "                      shown.  The list may include both membernames and   "
say "                      filenames in any order.  Filenames will be isolated "
say "                      and all specified members will be located in every  "
say "                      dataset of each identified file.                    "
say "                 NOTE that this requires the caller to specify EVERY DD to"
say "                      be searched.  If no DDs are specified, the default  "
say "                      is SYSEXEC + SYSPROC.                               "
"NEWSTACK" ; pull ; "CLEAR" ; "DELSTACK"
say "                                                                          "
say "            pkg-list  is a KEYPHRS-format list of packages (a series of   "
say "                      words bracketed by two-character delimiters).  e.g.:"
say "                        .pkgs ++ work datemgr xlate ++                    "
say "                      Package components are obtained via SMPKG.          "
say "                                                                          "
say "            LOG       (switch in parms) directs the process log be kept at"
say "                      process-end.                                        "
"NEWSTACK" ; pull ; "CLEAR" ; "DELSTACK"
say "   Debugging tools provided include:                                      "
say "                                                                          "
say "        MONITOR   displays key information throughout processing.         "
say "                  Displays most paragraph names upon entry.               "
say "                                                                          "
say "        NOUPDT    by-pass all update logic.                               "
say "                                                                          "
say "        BRANCH    show all paragraph entries.                             "
say "                                                                          "
say "        TRACE tv  will use value following TRACE to place the             "
say "                  execution in REXX TRACE Mode.                           "
say "                                                                          "
say "                                                                          "
say "   Debugging tools can be accessed in the following manner:               "
say "                                                                          "
say "        TSO "ex_nam"  parameters     ((  debug-options                    "
say "                                                                          "
say "   For example                                                            "
say "                                                                          "
say "        TSO "ex_nam"  (( MONITOR TRACE ?R                                 "

if sysvar("SYSISPF") = "ACTIVE" then,
address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/*
.  ----------------------------------------------------------------- */
BRANCH: Procedure expose,              /*@                           */
        sigl exec_name
   rc = trace("O")                     /* we do not want to see this */
   arg brparm .

   origin = sigl                       /* where was I called from ?  */
   do currln = origin to 1 by -1       /* inch backward to label     */
      if Right(Word(Sourceline(currln),1),1) = ":" then do
         parse value sourceline(currln) with pgfname ":" .  /* Label */
         leave ; end                   /*                name        */
   end                                 /* currln                     */

   select
      when brparm = "NAME" then return(pgfname) /* Return full name  */
      when brparm = "ID"      then do           /* wants the prefix  */
         parse var pgfname pgfpref "_" .        /* get the prefix    */
         return(pgfpref)
         end                           /* brparm = "ID"              */
      otherwise
         say left(sigl,6) left(pgfname,40) exec_name "Time:" time("L")
   end                                 /* select                     */

return                                 /*@ BRANCH                    */
/*
.  ----------------------------------------------------------------- */
DUMP_QUEUE:                            /*@ Take whatever is in stack */
   rc = trace("O")                     /*  and write to the screen   */
   address TSO
   arg mode .

   "QSTACK"                            /* how many stacks?           */
   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */
   if stk2dump = 0 & queued() = 0 then return
   if mode <> "QUIET" then,
   say "Total Stacks" rc ,             /* rc = #of stacks            */
    "   Begin Stacks" tk_init_stacks , /* Stacks present at start    */
    "   Excess Stacks to dump" stk2dump

   do dd = rc to tk_init_stacks by -1  /* empty each one.            */
      if mode <> "QUIET" then,
      say "Processing Stack #" dd "   Total Lines:" queued()
      do queued();parse pull line;say line;end /* pump to the screen */
      "DELSTACK"                       /* remove stack               */
   end                                 /* dd = 1 to rc               */

return                                 /*@ DUMP_QUEUE                */
/* Handle CLIST-form keywords             added 20020513
.  ----------------------------------------------------------------- */
CLKWD: Procedure expose info           /*@ hide all except info      */
   arg kw
   kw = kw"("                          /* form is 'KEY(DATA)'        */
   kw_pos = Pos(kw,info)               /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   rtpt   = Pos(") ",info" ",kw_pos)   /* locate end-paren           */
   slug   = Substr(info,kw_pos,rtpt-kw_pos+1)     /* isolate         */
   info   = Delstr(info,kw_pos,rtpt-kw_pos+1)     /* excise          */
   parse var slug (kw)     slug        /* drop kw                    */
   slug   = Reverse(Substr(Reverse(Strip(slug)),2))
return slug                            /*@CLKWD                      */
/* Handle multi-word keys 20020513
.  ----------------------------------------------------------------- */
KEYWD: Procedure expose info           /*@ hide all vars, except info*/
   arg kw
   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   kw_val = word(info,kw_pos+Words(kw))/* get the next word          */
   info   = Delword(info,kw_pos,2)     /* remove both                */
return kw_val                          /*@ KEYWD                     */
/*
.  ----------------------------------------------------------------- */
KEYPHRS: Procedure expose,             /*@                           */
         info helpmsg exec_name        /*  except these three        */
   arg kp
   wp    = wordpos(kp,info)            /* where is it?               */
   if wp = 0 then return ""            /* not found                  */
   front = subword(info,1,wp-1)        /* everything before kp       */
   back  = subword(info,wp+1)          /* everything after kp        */
   parse var back dlm back             /* 1st token must be 2 bytes  */
   if length(dlm) <> 2 then            /* Must be two bytes          */
      helpmsg = helpmsg,
         "Invalid length for delimiter("dlm") with KEYPHRS("kp")",
         info
   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/
      helpmsg = helpmsg,
         "No matching second delimiter("dlm") with KEYPHRS("kp")",
         info
   if helpmsg <> "" then call HELP     /* Something is wrong         */
   parse var back kpval (dlm) back     /* get everything b/w delim   */
   info =  front back                  /* restore remainder          */
return Strip(kpval)                    /*@ KEYPHRS                   */
/*
.  ----------------------------------------------------------------- */
NOVALUE:                               /*@                           */
   say exec_name "raised NOVALUE at line" sigl
   say " "
   say "The referenced variable is" condition("D")
   say " "
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ NOVALUE                   */
/*
.  ----------------------------------------------------------------- */
SHOW_SOURCE:                           /*@                           */
   call DUMP_QUEUE                     /* Spill contents of stacks  -*/
   if sourceline() <> "0" then         /* to screen                  */
      say sourceline(zsigl)
   rc =  trace("?R")
   nop
   exit                                /*@ SHOW_SOURCE               */
/*
.  ----------------------------------------------------------------- */
SS: Procedure                          /*@ Show Source               */
   arg  ssbeg  ssend  .
   if ssend = "" then ssend = 10
   if \datatype(ssbeg,"W") | \datatype(ssend,"W") then return
   ssend = ssbeg + ssend
   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end
return                                 /*@ SS                        */
/*
.  ----------------------------------------------------------------- */
SWITCH: Procedure expose info          /*@                           */
   arg kw
   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */
   if sw_val then                      /* exists                     */
      info = Delword(info,Wordpos(kw,info),1) /* remove it           */
return sw_val                          /*@ SWITCH                    */
/*
.  ----------------------------------------------------------------- */
SYNTAX:                                /*@                           */
   errormsg = exec_name "encountered REXX error" rc "in line" sigl":",
                        errortext(rc)
   say errormsg
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ SYNTAX                    */
/*
   Can call TRAPOUT.
.  ----------------------------------------------------------------- */
TOOLKIT_INIT:                          /*@                           */
   address TSO
   info = Strip(opts,"T",")")          /* clip trailing paren        */

   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,
                     as_invokt  cmd_env  addr_spc  usr_tokn

   parse value "" with  tv  helpmsg  .
   parse value 0   "ISR00000  YES"     "Error-Press PF1"    with,
               sw.  zerrhm    zerralrm  zerrsm

   if SWITCH("TRAPOUT") then do
      "TRAPOUT" exec_name parms "(( TRACE R" info
      exit
      end                              /* trapout                    */

   sw.0nested   = sysvar("SYSNEST") = "YES"
   sw.0batch    = sysvar("SYSENV")  = "BACK"
   sw.0inispf   = sysvar("SYSISPF") = "ACTIVE"
   parse value KEYWD("TRACE")  "N"    with   tv  .

   if Word(parms,1) = "?" then call HELP /* I won't be back          */

   "QSTACK" ; tk_init_stacks = rc      /* How many stacks?           */

   parse value SWITCH("BRANCH") SWITCH("MONITOR") SWITCH("NOUPDT") with,
               branch           monitor           noupdt    .

   parse value mvsvar("SYSNAME") sysvar("SYSNODE") with,
               #tk_cpu           node          .

   tk_globalvars = "exec_name  tv  helpmsg  sw.  zerrhm  zerralrm ",
                   "zerrsm  zerrlm  tk_init_stacks  branch  monitor ",
                   "noupdt"

   call LOCAL_PREINIT                  /* for more opts             -*/

return                                 /*@ TOOLKIT_INIT              */
/*
     SHOWTBL : K( DATASET MEMNAME DDNAME )
               N( VV MM CREATED CHANGED TIME SIZE INIT MOD ID AL SEQ )
*/
/*
))) PLIB POP50BY4    Generic warning pop-up
)ATTR
    %  TYPE(TEXT)   INTENS(HIGH)   SKIP(ON)
)BODY WINDOW(50,4)
+&popmsg1
+&popmsg2
+&popmsg3
+&popmsg4
)INIT
)PROC
)END
))) PLIB SHOWMEM     Primary display
)ATTR DEFAULT(%+_)
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  @ TYPE(TEXT) INTENS(NON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD(_)
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  * TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
   TYPE(OUTPUT) INTENS(low) color(red)
  # TYPE(INPUT) INTENS(LOW) CAPS(ON) JUST(LEFT)
)BODY EXPAND(||)
+ |-|%SHOW Member(s) with ISPF Stats+|-|
%COMMAND ===>$ZCMD                                            %SCROLL ===>$AMT +
+
% S Member   Dataset                                          DDname
+                VV MM   Created     Changed    Time   Size  Init  Mod  ID
+===============================================================================
)MODEL
 $Z*MEMNAME *DATASET                                     +   *DDNAME
   al          #VV#MM+#CREATED   +#CHANGED   +#TIME +#SIZE+#INIT+#MOD+#ID     +
)INIT
  .HELP   = SMHELP
  .ZVARS  = '(ACTION)'
  .CURSOR = ACTION
)PROC
  VER (&ACTION,LIST,A,B,C,D,E,F,I,L,M,N,P,R,S,T,Z)
)END
))) PLIB SHOWMEM#    Special-use display
)ATTR DEFAULT(%+_)
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date- ---by------ -Description of change---------------------------- */
  /* 20030321 fxc        right-justify size, init, mod                      */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  @ TYPE(TEXT) INTENS(NON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD(_)
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  * TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
   TYPE(OUTPUT) INTENS(low) color(red)
  # TYPE(INPUT) INTENS(LOW) CAPS(ON) JUST(LEFT)
  } TYPE(INPUT) INTENS(LOW) CAPS(ON) JUST(RIGHT)
)BODY EXPAND(||)
+ |-|%SHOW Member(s) with ISPF Stats+|-|
%COMMAND ===>$ZCMD
                                                              %SCROLL ===>$AMT +
% S Member   Dataset                                          DDname
+                VV MM   Created     Changed    Time   Size  Init  Mod  ID
+===============================================================================
)MODEL
 $Z*MEMNAME *DATASET                                     +   *DDNAME
   al          #VV#MM+#CREATED   +#CHANGED   +#TIME +}SIZE+}INIT+}MOD+#ID     +
)INIT
  .HELP   = SMHELP
  .ZVARS  = '(ACTION)'
  .CURSOR = ACTION
)PROC
  &CRYY = TRUNC (&CREATED,'/')
  &VAL1 = .TRAIL
  &CRMM = TRUNC (&VAL1,'/')
  &VAL2 = .TRAIL
  &CRDD = TRUNC (&VAL2,'/')

  &CHYY = TRUNC (&CHANGED,'/')
  &VAL3 = .TRAIL
  &CHMM = TRUNC (&VAL3,'/')
  &VAL4 = .TRAIL
  &CHDD = TRUNC (&VAL4,'/')

  &HH   = TRUNC (&TIME,':')
  &MMM  = .TRAIL

  VER (&ACTION,LIST,A,B,C,D,E,F,I,L,M,N,P,R,S,T,Z,U,V)
  IF (&ACTION = 'U')
     VER (&VV,NB,RANGE,01,99)
     VER (&VV,LEN,EQ,2)
     VER (&MM,NB,PICT,99)
     VER (&CREATED,NB,PICT,9999/99/99)
     VER (&CHANGED,NB,PICT,9999/99/99)
     VER (&CRDD,NB,RANGE,01,31)
     VER (&CRMM,NB,RANGE,01,12)
     VER (&CHDD,NB,RANGE,01,31)
     VER (&CHMM,NB,RANGE,01,12)
     VER (&TIME,NB,PICT,99:99)
     VER (&TIME,LEN,EQ,5)
     VER (&HH,NB,RANGE,00,23)
     VER (&MMM,NB,RANGE,00,59)
     VER (&SIZE,NB,NUM)
     VER (&INIT,NB,NUM)
     VER (&MOD,NB,NUM)
     VER (&ID,NB,NAME)
)END
))) PLIB SMACQUR     Copy member dataset-to-dataset
)ATTR
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY WINDOW(62,10)
%COMMAND ===>$ZCMD                                          +
+
+From DSN%==>@DATASET                                       +
+     Mem%==>@MEMNAME +
+
+To   DSN%==>$TODSN                                         +
+     Mem%==>$TOMEM   +
+
+Log Task%==>$Z+ (Y/n) {Update Personal Task System}
+
)INIT
  .HELP    = SMHELPA1
  .ZVARS   = '(UPDTTASK)'
  .CURSOR  = TODSN
)PROC
 VER (&TODSN,NB,DSNAME)
 VER (&TOMEM,NB,NAME)
 VER (&UPDTTASK,NB,LIST,Y,N)
 VPUT (UPDTTASK) PROFILE
)END
))) PLIB SMCONFRM    Get permission to overlay data
)ATTR
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_') SKIP(OFF)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY WINDOW(45,10)
+
+
+Mem ==>@OLAYMEM +
+Dsn ==>@OLAYDSN                            +
+
+Member already exists in Dataset
+
+Overlay? ==> _Z+ (Yes/No)
+
+
)INIT
  .HELP = SMHELP
  .ZVARS = '(CONFIRM)'
  .CURSOR = CONFIRM
  &CONFIRM = 'N'
)PROC
 VER (&CONFIRM,NB,LIST,Y,N)
)END
))) PLIB SMCOPY      Multi-dataset copy
)ATTR
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY WINDOW(65,20)
%COMMAND ===>$ZCMD                                          +
+
+From DSN%==>@DATASET                                       +
+     Mem%==>@MEMNAME +
+
+TO   DSN%==>$OUTDSN1                                       +
+     Mem%==>$NEWMEM1 +
+
+TO   DSN%==>$OUTDSN2                                       +
+     Mem%==>$NEWMEM2 +
+
+TO   DSN%==>$OUTDSN3                                       +
+     Mem%==>$NEWMEM3 +
+
+Save DSN%==>$SAVEDSN                                       +
+     Mem%==>$NEWMEM4 +
+
+Backup? %==>_Z+ (Y/n) {Back up to SAVE datasets}
+Log?    %==>_Z+ (Y/n) {Update Task System}
+
)INIT
  .HELP    = SMHELPC1
  .ZVARS   = '(BACKUP UPDTTASK)'
  .CURSOR  = OUTDSN1
)PROC
 VER (&OUTDSN1,DSNAME)
 IF (&OUTDSN1 = '')
    VER (&NEWMEM1,NB,NAME)

 VER (&OUTDSN2,DSNAME)
 IF (&OUTDSN2 = '')
    VER (&NEWMEM2,NB,NAME)

 VER (&OUTDSN3,DSNAME)
 IF (&OUTDSN3 = '')
    VER (&NEWMEM3,NB,NAME)

 VER (&SAVEDSN,DSNAME)
 IF (&SAVEDSN = '')
    VER (&NEWMEM4,NB,NAME)

 VER (&UPDTTASK,NB,LIST,Y,N)
 VPUT (OUTDSN1 OUTDSN2 OUTDSN3 UPDTTASK BACKUP) PROFILE

 VER (&BACKUP,NB,LIST,Y,N)
 VER (&UPDTTASK,NB,LIST,Y,N)
)END
))) PLIB SMPRINTN    Print member
)ATTR
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY WINDOW(60,10)
%COMMAND ===>$ZCMD

+DSN   %==>@DATASET                                      +
+Member%==>@MEMNAME +
+
+      Class%==>$z+
+Destination%==>$DEST    +
+Copies     %==>$Z+
+Options    %==>$PRTOPTS

)INIT
  .HELP   = SMHELPP1
  .ZVARS  = '(PRCLS COPY)'
  .CURSOR = PRCLS
  &COPY   = '1'
)PROC
 VER (&PRCLS,NB)
 VER (&DEST,NB)
 VER (&COPY,NB,NUM)
)END
))) PLIB SMROLL      Migrate member backward/forward
)ATTR
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY WINDOW(61,13)
%COMMAND ===>$ZCMD                                          +
+
+From DSN%==>@DATASET                                       +
+     Mem%==>@MEMNAME +
+
+To   DSN%==>$TODSN                                         +
+Save DSN%==>$SAVEDSN                                       +
+     Mem%==>$TOMEM   +
+
+Backup? %==>$Z+ (Y/n) {Back up to SAVE datasets}
+Delete? %==>$Z+ (Y/n) {Delete Behind?}
+Log?    %==>$Z+ (Y/n) {Update Task System}
+
)INIT
  .HELP    = SMHELPR1
  .CURSOR  = TODSN
  .ZVARS   = '(BACKUP BEHIND UPDTTASK)'
)PROC
  VER (&TODSN,NB,DSNAME)
  VER (&TOMEM,NB,NAME)
  VER (&BACKUP,NB,LIST,Y,N)
  VER (&BEHIND,NB,LIST,Y,N)
  VER (&UPDTTASK,NB,LIST,Y,N)
  VPUT (BACKUP BEHIND UPDTTASK) PROFILE
)END
))) PLIB SMHELP      Main HELP panel
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* -Date- -by- -Description of change ----------------------------------- */
  /* 960124 fxc  link-in SMHELPFT                                           */
  /* 960212 ctl  Add help for option N                                      */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
+  1. Purpose of SHOWMEM
+  2. Use of SHOWPARM and SHOWTASK : external routines
+  3. Member Names vs. DDNames
+
+  A. Acquire Member
+  B. Browse Member
+  C. Copy/Roll Member
+  D. Delete Member
+  E. Edit Member
+  F. Specify "From" dataset
+  L. Browse Dataset
+  M. Edit Dataset
+  N. Ship Dataset/Member via NDM
+  P. Print Member
+  R. Roll Member
+  S. Endevor Signin - TSG Only
+  T. Specify "To" dataset
+
)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELP01
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELP01    Purpose of SHOWMEM
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19960212 ctlewis    link SMHELPN1                                      */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
   SHOWMEM allows for 1 to many parms which may be either DDNames or member
   names.  The valid DDNames are anything in your current concatenations plus
   JCLLIB, DOCLIB, SORCELIB, and PROCLIB.

   SHOWMEM will split the parm string to membernames and DDNames.  A search
   will be made of each member name in the datasets that are attached to the
   identified DDNames.  In addition to searching those datasets in the
   concatenation, a separate exec (SHOWPARM) is called to expand the list of
   datasets.  SHOWPARM may be customized to user specs.

   When a member is located in a dataset, its ISPF stats are loaded onto the
   table.  After the search is complete a scrollable table is presented.  From
   here the user may ACQUIRE, BROWSE, COPY, ROLL, DELETE, etc.

   SHOWMEM originated on a system using ENDEVOR/MVS Library Management and NDM
   (Network Data Mover) for inter-system transfers as well as other external
   software.  Foreign systems may use other external processes and will
   necessitate local adjustment of this code to adapt it to local conditions.

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELP02
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELP02    External routines
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19960212 ctlewis    link SMHELPN1                                      */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help - External Routines+|-|
%COMMAND ===>$ZCMD
+
   All execs called by SHOWMEM should be in a preferential location relative to
   ICEBERG

   SHOWDDNM is called to acquire a base list of DDNames.  These DDNames allow
   the user to include DDNames (for SHOWPARM) that are not referred to in the
   user's concatenations.

   SHOWPARM will allow for additional datasets to be included in the search by
   DDName.  Any valid DDName will be used.  This can be used with SHOWDDNM to
   include DDNames (and datasets) that are not in the user concatenation.
   SHOWMEM will call SHOWPARM passing the parm of DDNAME (ex.: SYSPROC, SYSEXEC
   ISPPLIB, etc.).  SHOWPARM will return a list of dataset names for SHOWMEM to
   include in its search of member names.

   Any duplicates in SHOWPARM will be ignored.

   SHOWTASK is an external routine called by SHOWMEM when the Update Personal
   Task System switch is set to {Y}.  This allows the user to customize a task
   system.  The same rules for SHOWPARM apply to SHOWTASK.
)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELP03
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELP03    Members vs DDs
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19960212 ctlewis    link SMHELPN1                                      */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
   Member Names vs. DDNames

   A DDName will be any DDName that is allocated to the users TSO session plus
   the additional default DDNames of JCLLIB, DOCLIB, SORCELIB, and PROCLIB.
   What remains will be considered member names.

   Caution: it is assumed that the member names conform to TSO naming
   conventions for PDS members (i.e. no longer than 8 bytes, first character is
   alphabetic, etc.).  SHOWMEM makes no check to validate a member name.

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELPA1
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELPA1    Acquire
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
   Acquire Member:

   There are two types of ACQUIRE.  The first type is an ENDEVOR acquire.  This
   will invoke ENDEVOR to RETRIEVE an element for the caller.  The second type
   is a standard acquire that will use IEBCOPY.

   The type of ACQUIRE to use is automatically determined.  If the dataset to
   acquire from is an ENDEVOR managed dataset, then an ENDEVOR RETRIEVE is
   performed.  ACQUIRE specifically looks for a dataset in the user's
   SYSEXEC/SYSPROC concatenation that starts with userid.ENDV.  If not found,
   then the first dataset in the SYSEXEC/SYSPROC concatenation is used.

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELPB1
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPM1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELPB1    Browse member
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
   Browse Member:

   Use <B> to Browse the member in the dataset.

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELPC1
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELPC1    Copy member
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
   Copy Member:

   A COPY allows the user to copy the member into 1-3 user specified datasets.
   The user may also specify the member name for each dataset.  For non-ENDEVOR
   datasets this option is equivalent to a ROLL.

   If any user specified dataset does not exist, it will be allocated.  The
   user may also back up to any SAVE dataset by setting the BACKUP switch {Y/N}
   on panel.  The user may also delete behind after the COPY and update a
   personal task system.

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELPD1
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELPD1    Delete member
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
   Delete Member:

   There are two types of DELETES:  ENDEVOR and non-ENDEVOR.  An ENDEVOR delete
   applies only to ENDEVOR managed datasets.  ENDEVOR will be invoked to perform
   the DELETE service.

   For non-ENDEVOR managed datasets, LM facilities are used to complete the
   delete.

   In either case after the delete has been completed with a valid return code,
   the row from the table will also be deleted.

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELPE1
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELPE1    Edit member
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
   Edit Member:

   Use <E> to edit the member in the dataset.

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELPL1
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELPL1    Browse Dataset
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
   Browse Dataset:

   Use <L> to browse the entire dataset.

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELPM1
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELPM1    Edit dataset
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
   Edit Dataset:

   Use <M> to edit the entire dataset.

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELPN1
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELPN1    Ship with NDM
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
    Ship Dataset/Member using NDM.

   Using the line command <N> will present a panel where the user will select
   the site(s) to ship to.  The valid sites will be all active sites minus the
   one the user is currently logged on to.  Place any non-blank character beside
   the site to select or deselect that site.

   If desired, enter the dataset name to ship to.  The default is the from
   dataset name.  You may also change the member name or leave it blank to ship
   the entire PDS.

   When all choices are made press <PF3> to begin processing or press <PF12> to
   cancel the request and return to the primary SHOWMEM panel.

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELPP1
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELPP1    Print dataset
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
   Print Dataset:

   If selected, a <P> will print the member to a VPS printer.

   On the panel the user can select the printer destination and the
   number of copies (1 to 9).

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELPR1
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELPR1    Roll member
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
   Roll Member:

   A ROLL is a customized ENDEVOR roll that should only be executed for ENDEVOR
   managed datasets on the base complex.  Based upon the dataset, the action to
   performed will be an ADD or a MOVE.  An ADD is used if the ROLL is ocurring
   from any dataset that is not the production or test dataset.  A MOVE is
   performed is the dataset is a TEST dataset.

   On the panel the user can specify if a backup to the SAVE dataset is be done.
   The backup will occur before ENDEVOR processing.  If 'delete behind' is
   requested then SCL is built to delete behind.  If sucessful then the row from
   the table will also be deleted.  The user may also update the Personal Task
   System.

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELPS1
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELPS1    ENDEVOR Sign-In
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* --Date-- --by------ -Description of change --------------------------- */
  /* 19991020 F.Clarke   cosmetics                                          */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
   Sign-in Member:

   A SIGN-IN is an ENDEVOR function that may only be executed at the base site.
   The sign-in must occur from a user dataset.  An element can not be signed in
   when it is already in ENDEVOR.  The user must select whether the sign-in
   should be into PROD or TEST.  The user may also request the member to be
   deleted from the work library.  The stage to sign-in TO is the stage from
   which the member was retrieved.

   The purpose of a sign-in is to clear a SIGNOUT that occured during a
   RETRIEVE, ADD, or MOVE action.

)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELPFT
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
))) PLIB SMHELPFT    Repopulate FROM and TO
)ATTR
  /* ------ Change Log ---------------------------------------------------- */
  /* -Date- -by- -Description of change ----------------------------------- */
  /* 960124 fxc  New                                                        */
  /* ---------------------------------------------------------------------- */
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
   TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  ! TYPE(TEXT) INTENS(NON)
  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY  EXPAND(||)
+|-|%SHOWMEM Help+|-|
%COMMAND ===>$ZCMD
+
%  "From"+and%"To"+dataset specifications:
+
+  Datasets may be%repopulated+one from another.  To do this, specify
%  ONE+and%ONLY ONE row+as the%FROM-line ("F")+and%AT LEAST ONE row+as
+  the%TO-line(s) ("T").
+
+  The data and all relevant ISPF statistics will be%replicated onto
%  the TO-datasets+using the%FROM-dataset+as the source.
+
)INIT
)PROC
  &ZSEL = TRANS(&ZCMD
             ' ',SMHELP
               1,SMHELP01
               2,SMHELP02
               3,SMHELP03
               A,SMHELPA1
               B,SMHELPB1
               C,SMHELPC1
               D,SMHELPD1
               E,SMHELPE1
               F,SMHELPFT
               L,SMHELPL1
               M,SMHELPM1
               N,SMHELPN1
               P,SMHELPP1
               R,SMHELPR1
               S,SMHELPS1
               T,SMHELPFT
               )
)END
*/
